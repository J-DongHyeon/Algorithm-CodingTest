
첫 번째 방법으로, 문자열들을 정렬한 후 이진탐색을 하는 방법으로 문제를 풀이하였다.
문자열들에 대해 아스키코드 순으로 정렬해야 하기 때문에 Counting Sort 는 불가능 하였다.
시간 복잡도가 O(n logn) 인 정렬 방법 중, 퀵 정렬을 한번 이용해보고자 하였다.


이 문제에 대해 다른 사람의 풀이법을 찾아보니, Hash Table 을 이용하여 푸는 방법도 있었다.
따라서 Hash Table 을 구현하여 문제를 풀어보았다.
  1. 데이터 충돌에 대해서는 Chaining 방법을 이용하여 해결하였다.
  2. 해시 함수는 나눗셈 법으로 구현하였다.
  3. 해시 테이블의 크기를 1000, 5000, 10000, 20000 으로 각각 실행 해보았는데, 실행 속도의 차이는 크게 나지 않았다.
  4. 위의 퀵 정렬, 이진 탐색을 이용한 방법과 비교해 보았을 때, 해시 테이블을 이용한 방법이 메모리를 200 KB 더 사용하고, 실행 속도도 50 ms 더 느리다.


문제를 풀면서 공부한 부분
  1. 퀵 정렬 알고리즘 구현 방법
  2. 문자열들을 char 자료형 이중 포인터로 처리하는 방법 (char 자료형 이중 포인터, 단일 포인터에 메모리 할당하기)
  3. 포인터 배열, 배열 포인터에 대한 개념 정리
  4. 해시 테이블의 개념, 구현 방법 (Chaining, Open Addressing, 해시 함수 구현 방법)
  5. 구조체 사용법 숙지 (typedef, 멤버 필드 초기화)
